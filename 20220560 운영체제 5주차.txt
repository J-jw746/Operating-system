문제 1 완벽 해설
주어진 정보:
 * 5개의 스레드 (T1, T2, T3, T4, T5)가 있습니다.
 * 모든 스레드는 시간 0에 도착합니다.
 * 스레드들은 중단 없이 실행됩니다.
 * 우선순위가 낮을수록 숫자가 작고, 높을수록 숫자가 큽니다.
스레드 정보:
| 스레드 | 실행 시간 (ms) | 우선순위 |
|---|---|---|
| T1 | 2 | 2 |
| T2 | 1 | 1 |
| T3 | 8 | 4 |
| T4 | 4 | 3 |
| T5 | 3 | 5 |
(1) FCFS, SJF, Non-Preemptive Priority 스케줄링 알고리즘 각각에 대해 스레드들이 스케줄링되어 실행되는 과정을 차트를 그리고, 그리고 5개의 스레드의 평균 대기 시간을 계산하라.
FCFS (First-Come, First-Served - 선입선출)
도착 순서대로 스케줄링합니다. 모든 스레드가 시간 0에 도착했으므로 스레드 ID 순서대로 실행됩니다.
 * 실행 차트:
   0   2   3       11      15          18
| T1| T2|-------T3------|----T4-----|---T5---|

 * 각 스레드의 완료 시간:
   * T1 완료 시간: 2ms
   * T2 완료 시간: 2 + 1 = 3ms
   * T3 완료 시간: 3 + 8 = 11ms
   * T4 완료 시간: 11 + 4 = 15ms
   * T5 완료 시간: 15 + 3 = 18ms
 * 각 스레드의 대기 시간: (시작 시간 - 도착 시간)
   * T1 대기 시간: 0 - 0 = 0ms
   * T2 대기 시간: 2 - 0 = 2ms
   * T3 대기 시간: 3 - 0 = 3ms
   * T4 대기 시간: 11 - 0 = 11ms
   * T5 대기 시간: 15 - 0 = 15ms
 * 평균 대기 시간: (0 + 2 + 3 + 11 + 15) / 5 = 31 / 5 = 6.2ms
SJF (Shortest Job First - 최단 작업 우선)
실행 시간이 가장 짧은 스레드부터 스케줄링합니다.
 * 실행 차트:
   0   1   3   6       14          18
| T2| T1| T5|-------T3------|----T4-----|

 * 각 스레드의 완료 시간:
   * T2 완료 시간: 1ms
   * T1 완료 시간: 1 + 2 = 3ms
   * T5 완료 시간: 3 + 3 = 6ms
   * T3 완료 시간: 6 + 8 = 14ms
   * T4 완료 시간: 14 + 4 = 18ms
 * 각 스레드의 대기 시간:
   * T2 대기 시간: 0 - 0 = 0ms
   * T1 대기 시간: 1 - 0 = 1ms
   * T5 대기 시간: 3 - 0 = 3ms
   * T3 대기 시간: 6 - 0 = 6ms
   * T4 대기 시간: 14 - 0 = 14ms
 * 평균 대기 시간: (0 + 1 + 3 + 6 + 14) / 5 = 24 / 5 = 4.8ms
Non-Preemptive Priority (비선점 우선순위)
도착한 스레드 중 우선순위가 가장 높은 스레드부터 스케줄링합니다. 우선순위가 높을수록 숫자가 큽니다.
 * 실행 차트:
   0   3   6       14      16          18
| T5| T3|-------T4------|--T1--|----T2----|

 * 각 스레드의 완료 시간:
   * T5 완료 시간: 3ms (우선순위 5)
   * T3 완료 시간: 3 + 8 = 11ms (우선순위 4)
   * T4 완료 시간: 11 + 4 = 15ms (우선순위 3)
   * T1 완료 시간: 15 + 2 = 17ms (우선순위 2)
   * T2 완료 시간: 17 + 1 = 18ms (우선순위 1)
 * 각 스레드의 대기 시간:
   * T5 대기 시간: 0 - 0 = 0ms
   * T3 대기 시간: 3 - 0 = 3ms
   * T4 대기 시간: 11 - 0 = 11ms
   * T1 대기 시간: 15 - 0 = 15ms
   * T2 대기 시간: 17 - 0 = 17ms
 * 평균 대기 시간: (0 + 3 + 11 + 15 + 17) / 5 = 46 / 5 = 9.2ms
(2) RR (Round Robin - 순환 할당, 타임 슬라이스 = 2ms)으로 스케줄링할 때 실행되는 과정을 차트로 그리고, 그리고 5개의 스레드의 평균 대기 시간을 계산하라.
각 스레드는 2ms의 타임 슬라이스를 번갈아 가며 할당받습니다.
 * 실행 차트:
   0  2  3  5  7  9 11 13 15 17 18
|T1|T2|T3|T4|T5|T1|T3|T4|T3|T5|T3|

 * 각 스레드의 완료 시간:
   * T1 완료 시간: 9ms (2ms + 2ms = 4ms 실행)
   * T2 완료 시간: 3ms (1ms 실행)
   * T3 완료 시간: 18ms (2ms * 4 = 8ms 실행)
   * T4 완료 시간: 13ms (2ms * 2 = 4ms 실행)
   * T5 완료 시간: 17ms (2ms + 1ms = 3ms 실행)
 * 각 스레드의 시작 시간:
   * T1: 0ms, 5ms
   * T2: 2ms
   * T3: 3ms, 7ms, 15ms
   * T4: 5ms, 11ms
   * T5: 9ms, 17ms
 * 각 스레드의 대기 시간: (총 시작 시간 - 총 실행 시간)
   * T1 대기 시간: (0 + 5) - 2 = 3ms
   * T2 대기 시간: 2 - 1 = 1ms
   * T3 대기 시간: (3 + 7 + 15) - 8 = 17ms
   * T4 대기 시간: (5 + 11) - 4 = 12ms
   * T5 대기 시간: (9 + 17) - 3 = 23ms
 * 평균 대기 시간: (3 + 1 + 17 + 12 + 23) / 5 = 56 / 5 = 11.2ms
(3) RR (Round Robin - 순환 할당, 타임 슬라이스 = 0.3ms)으로 스케줄링할 때 5개의 스레드가 모두 실행되는 첫 번째 검문 시간은 얼마인가?
각 스레드가 최소한 한 번 CPU를 할당받는 시간을 묻는 문제입니다. 타임 슬라이스가 0.3ms로 매우 작으므로 스레드 전환이 빈번하게 일어납니다.
 * 각 스레드가 한 번씩 실행되는 데 필요한 시간은 0.3ms * 5 = 1.5ms 입니다.
 * 따라서 5개의 스레드가 모두 실행되는 첫 번째 검문 시간은 1.5ms 입니다.
문제 2 완벽 해설
주어진 정보:
 * 5개의 스레드 (T1, T2, T3, T4, T5)가 있습니다.
 * 도착 시간이 다릅니다.
 * 스레드들은 중단 없이 실행됩니다.
 * 우선순위가 낮을수록 숫자가 작고, 높을수록 숫자가 큽니다.
스레드 정보:
| 스레드 | 도착 시간 (ms) | 실행 시간 (ms) | 우선순위 |
|---|---|---|---|
| T1 | 0 | 4 | 3 |
| T2 | 0 | 3 | 2 |
| T3 | 0 | 8 | 5 |
| T4 | 1 | 5 | 1 |
| T5 | 9 | 5 | 4 |
(1) FCFS, SJF, Non-Preemptive Priority 스케줄링 알고리즘 각각에 대해 스레드들이 스케줄링되어 실행되는 과정을 차트를 그리고, 그리고 5개의 스레드의 평균 대기 시간을 계산하라.
FCFS (First-Come, First-Served - 선입선출)
도착 순서대로 스케줄링합니다. T1, T2, T3가 시간 0에 도착했으므로 이 순서대로 먼저 실행됩니다. T4는 시간 1에 도착하여 T3 실행 완료 후 실행되고, T5는 시간 9에 도착하여 T4 실행 완료 후 실행됩니다.
 * 실행 차트:
   0   4   7       15          20          25
| T1| T2|-------T3------|----T4-----|----T5-----|

 * 각 스레드의 완료 시간:
   * T1 완료 시간: 4ms
   * T2 완료 시간: 4 + 3 = 7ms
   * T3 완료 시간: 7 + 8 = 15ms
   * T4 완료 시간: 15 + 5 = 20ms
   * T5 완료 시간: 20 + 5 = 25ms
 * 각 스레드의 대기 시간: (시작 시간 - 도착 시간)
   * T1 대기 시간: 0 - 0 = 0ms
   * T2 대기 시간: 4 - 0 = 4ms
   * T3 대기 시간: 7 - 0 = 7ms
   * T4 대기 시간: 15 - 1 = 14ms
   * T5 대기 시간: 20 - 9 = 11ms
 * 평균 대기 시간: (0 + 4 + 7 + 14 + 11) / 5 = 36 / 5 = 7.2ms
SJF (Shortest Job First - 최단 작업 우선)
현재 실행 가능한 스레드 중 실행 시간이 가장 짧은 스레드부터 스케줄링합니다.
 * 시간 0: T1(4), T2(3), T3(8) 도착. 가장 짧은 T2 실행.
 * 시간 3: T2 완료. 실행 가능한 스레드는 T1(4), T3(8). 가장 짧은 T1 실행.
 * 시간 4: T4(5) 도착.
 * 시간 7: T1 완료. 실행 가능한 스레드는 T3(8), T4(5). 가장 짧은 T4 실행.
 * 시간 9: T5(5) 도착.
 * 시간 12: T4 완료. 실행 가능한 스레드는 T3(8), T5(5). 가장 짧은 T5 실행.
 * 시간 17: T5 완료. 남은 스레드는 T3(8) 실행.
 * 실행 차트:
   0   3   7       12          17          25
| T2| T1|----T4-----|----T5-----|-------T3------|

 * 각 스레드의 완료 시간:
   * T2 완료 시간: 3ms
   * T1 완료 시간: 7ms
   * T4 완료 시간: 12ms
   * T5 완료 시간: 17ms
   * T3 완료 시간: 25ms
 * 각 스레드의 대기 시간:
   * T2 대기 시간: 0 - 0 = 0ms
   * T1 대기 시간: 3 - 0 = 3ms
   * T4 대기 시간: 7 - 1 = 6ms
   * T5 대기 시간: 12 - 9 = 3ms
   * T3 대기 시간: 17 - 0 = 17ms
 * 평균 대기 시간: (0 + 3 + 6 + 3 + 17) / 5 = 29 / 5 = 5.8ms
Non-Preemptive Priority (비선점 우선순위)
현재 실행 가능한 스레드 중 우선순위가 가장 높은 스레드부터 스케줄링합니다. 우선순위가 높을수록 숫자가 큽니다.
 * 시간 0: T1(P3), T2(P2), T3(P5) 도착. 가장 높은 우선순위는 T3(5). T3 실행.
 * 시간 1: T4(P1) 도착. T3는 계속 실행.
 * 시간 8: T3 완료. 실행 가능한 스레드는 T1(P3), T2(P2), T4(P1). 가장 높은 우선순위는 T1(3). T1 실행.
 * 시간 9: T5(P4) 도착. T1는 계속 실행.
 * 시간 12: T1 완료. 실행 가능한 스레드는 T2(P2), T4(P1), T5(P4). 가장 높은 우선순위는 T5(4). T5 실행.
 * 시간 17: T5 완료. 실행 가능한 스레드는 T2(P2), T4(P1). 가장 높은 우선순위는 T2(2). T2 실행.
 * 시간 20: T2 완료. 남은 스레드는 T4(P1) 실행.
 * 실행 차트:
   0       8       12          17          20          25
|-------T3------|----T1-----|----T5-----|----T2-----|----T4-----|

 * 각 스레드의 완료 시간:
   * T3 완료 시간: 8ms
   * T1 완료 시간: 12ms
   * T5 완료 시간: 17ms
   * T2 완료 시간: 20ms
   * T4 완료 시간: 25ms
 * 각 스레드의 대기 시간:
   * T3 대기 시간: 0 - 0 = 0ms
   * T1 대기 시간: 8 - 0 = 8ms
   * T5 대기 시간: 12 - 9 = 3ms
   * T2 대기 시간: 17 - 0 = 17ms
   * T4 대기 시간: 20 - 1 = 19ms
 * 평균 대기 시간: (0 + 8 + 3 + 17 + 19) / 5 = 47 / 5 = 9.4ms
(2) SRTF (Shortest Remaining Time First - 잔여 시간 최단 우선)
현재 실행 가능한 스레드 중 잔여 실행 시간이 가장 짧은 스레드부터 스케줄링합니다. 새로운 스레드가 도착했을 때, 현재 실행 중인 스레드의 남은 시간보다 도착한 스레드의 실행 시간이 더 짧으면 현재 실행 중인 스레드를 선점하고 도착한 스레드를 실행합니다.
 * 시간 0: T1(4), T2(3), T3(8) 도착. 잔여 시간: T1(4), T2(3), T3(8). 가장 짧은 T2 실행.
 * 시간 1: T4(5) 도착. 현재 T2 잔여 시간 2ms. T4 실행 시간 5ms. 선점 안 함.
 * 시간 3: T2 완료. 잔여 시간: T1(4), T3(8), T4(5). 가장 짧은 T1 실행.
 * 시간 4: T1 잔여 시간 3ms.
 * 시간 7: T1 완료. 잔여 시간: T3(8), T4(5).

CFS(Completely Fair Scheduling)의 필요성
CFS는 이전 리눅스 스케줄러의 한계를 극복하고 CPU 자원을 보다 강력하고 공정하게 관리하기 위해 리눅스 커널에 도입되었습니다. CFS가 필요한 이유는 다음과 같습니다.
 * 공정성: 이름에서 알 수 있듯이 CFS의 핵심 원칙은 공정성입니다. 각 실행 가능한 프로세스에 할당된 가중치(우선순위)에 따라 CPU 시간을 공정하게 분배하여 특정 프로세스가 CPU를 독점하는 것을 방지하고 모든 프로세스가 진척도를 보장받도록 합니다.
 * 응답성: 목표 지연 시간과 할당 시간을 동적으로 조정함으로써 CFS는 특히 대화형 작업에서 우수한 시스템 응답성을 유지하는 데 도움을 줍니다. 시스템 부하가 높은 상황에서도 대화형 애플리케이션은 충분한 CPU 시간을 할당받아 사용자가 쾌적하게 느낄 수 있도록 합니다.
 * 다양한 우선순위 처리: CFS는 가중치를 사용하여 프로세스 우선순위를 나타냅니다. 이를 통해 낮은 우선순위 프로세스를 완전히 배제하지 않으면서 높은 우선순위 프로세스에 더 많은 CPU 시간을 비례적으로 할당할 수 있습니다.
 * 기아 현상 방지: 가상 실행 시간을 추적하고 항상 가장 작은 가상 실행 시간을 가진 프로세스를 다음에 실행하도록 선택하는 CFS의 설계는 본질적으로 프로세스 기아 현상을 방지합니다. 모든 실행 가능한 프로세스는 결국 실행 기회를 얻게 됩니다.
 * 확장성: CFS는 많은 수의 프로세스를 효율적으로 관리할 수 있도록 설계되어 확장성이 뛰어납니다. 스케줄링 결정 알고리즘이 비교적 효율적입니다.
 * 복잡성 관리: CFS의 내부 메커니즘은 복잡하지만, 이전 스케줄러에 비해 수동 튜닝의 필요성이 적습니다. 동적인 조정 기능은 시스템이 변화하는 작업 부하에 자동으로 적응하도록 돕습니다.
요약하자면, CFS는 현대 운영체제인 리눅스에서 보다 균형 잡히고 효율적인 CPU 스케줄링 방식을 제공하여 공정성, 응답성을 보장하고 특히 다양하고 동적인 컴퓨팅 환경에서 기아 현상과 같은 문제를 예방합니다.
